
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;

public class Frame extends javax.swing.JFrame {

    private BufferedImage backBuffer;
    private BufferedImage map;
    
    private Point.Double cameraPosition = new Point.Double(50, 50);
    private double cameraAngle = 0;
    private double cameraFOV = Math.toRadians(60);
    
    private int projectionPlaneWidth = 300;
    private int projectionPlaneHeight = 300;
    private double d; // distance between camera and projection plane
    
    /**
     * Creates new form Frame
     */
    public Frame() {
        initComponents();
        setLocationRelativeTo(null);
        
        // create back buffer
        backBuffer = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_ARGB);
        
        // load map image
        try {
            map = ImageIO.read(getClass().getResourceAsStream("map.png"));
            System.out.println("wall color:" + map.getRGB(0, 0));
        } catch (IOException ex) {
            Logger.getLogger(Frame.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        d = (projectionPlaneWidth / 2) / Math.tan(cameraFOV / 2);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 900, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 499, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Frame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Frame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Frame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Frame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Frame().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    @Override
    public void paint(Graphics g) {
        draw((Graphics2D) backBuffer.getGraphics());
        g.drawImage(backBuffer, 0, 0, null);
                
    }
    
    public void draw(Graphics2D g) {
        g.setBackground(Color.WHITE);
        g.clearRect(0, 0, getWidth(), getHeight());
        g.translate(50, 50);
        g.drawImage(map, 0, 0, null);
        g.setColor(Color.RED);
        g.fillOval((int) (cameraPosition.x - 3), (int) (cameraPosition.y - 3), 6, 6);
        // draw walls
        for (int x=-(projectionPlaneWidth / 2); x<(projectionPlaneWidth / 2); x++) {
            double a = Math.atan(x / d);
            double cameraWallDistance = castRay(cameraPosition.x, cameraPosition.y, cameraAngle - a, g, Color.BLUE);
            double z = cameraWallDistance * Math.cos(a);
            drawWall3D(g, z, x + 550);
        }
        // draw camera direction
        castRay(cameraPosition.x, cameraPosition.y, cameraAngle, g, Color.RED);
    }

    private void drawWall3D(Graphics g, double z, int x) {
        double p = z / 300;
        p = p > 1 ? 1 : p;
        p = p < 0 ? 0 : p;
        int ic = (int) (p * 255);
        int wallHeight = (int) (d * 20 / z);
        wallHeight = wallHeight > projectionPlaneHeight / 2 ? projectionPlaneHeight / 2 : wallHeight;
        g.setColor(new Color(ic, ic, ic));
        g.drawLine(x, projectionPlaneHeight / 2 - wallHeight, x, projectionPlaneHeight / 2 + wallHeight);
    }
    
    private double castRay(double cameraPositionX, double cameraPositionY, double cameraDirectionAngle, Graphics g, Color rayColor) {
        double s = Math.sin(cameraDirectionAngle);
        double c = Math.cos(cameraDirectionAngle);
        double d = 0;
        int currentColor = 0;
        do {
            d += 0.1;
            int px = (int) (cameraPositionX + d * s);
            int py = (int) (cameraPositionY + d * c);
            currentColor = map.getRGB(px, py);
        } while (currentColor == -1);
        g.setColor(rayColor);
        g.drawLine((int) cameraPositionX, (int) cameraPositionY, (int) (cameraPositionX + d * s), (int) (cameraPositionY + d * c));
        return d;
    }

    private void moveCamera(double d, double a) {
        double angle = cameraAngle + a;
        double s = Math.sin(angle);
        double c = Math.cos(angle);
        cameraPosition.x += d * s;
        cameraPosition.y += d * c;
    }

    @Override
    protected void processKeyEvent(KeyEvent ke) {
        
        if (ke.getKeyCode() == 37) {
            moveCamera(1d, Math.toRadians(90));
        }
        else if (ke.getKeyCode() == 39) {
            moveCamera(1d, Math.toRadians(-90));
        }

        if (ke.getKeyCode() == 38) {
            moveCamera(1d, 0);
        }
        else if (ke.getKeyCode() == 40) {
            moveCamera(-1d, 0);
        }

        if (ke.getKeyCode() == 90) {
            cameraAngle += 0.1;
        }
        else if (ke.getKeyCode() == 88) {
            cameraAngle -= 0.1;
        }
        
        repaint();
    }
    
}
